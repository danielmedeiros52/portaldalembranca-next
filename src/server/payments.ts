import { env } from "~/env";
import { MercadoPagoConfig, Payment } from "mercadopago";
import { getDb } from "./db";
import { paymentTransactions, subscriptions } from "../../drizzle/schema";
import type { InsertPaymentTransaction, InsertSubscription } from "../../drizzle/schema";
import { eq, and } from "drizzle-orm";

// Initialize Mercado Pago client
const client = new MercadoPagoConfig({
  accessToken: env.MERCADOPAGO_ACCESS_TOKEN ?? "",
  options: {
    timeout: 5000,
  },
});

const payment = new Payment(client);

// Product definitions for Portal da Lembrança plans
const PAYMENT_PRODUCTS: Record<
  string,
  {
    price: number;
    name: string;
    description: string;
  }
> = {
  essencial: {
    price: 1990, // R$ 19.90 in cents
    name: "Memorial Essencial",
    description: "1 Memorial Digital com até 10 fotos",
  },
  premium: {
    price: 9990, // R$ 99.90 in cents
    name: "Memorial Premium",
    description: "1 Memorial com galeria ilimitada",
  },
  familia: {
    price: 24990, // R$ 249.90 in cents
    name: "Plano Família",
    description: "Até 5 memoriais com tudo do premium",
  },
};

/**
 * Maps Mercado Pago payment status to internal database status.
 */
function mapPaymentStatus(mpStatus: string): "pending" | "succeeded" | "failed" | "refunded" | "cancelled" {
  const statusMap: Record<string, "pending" | "succeeded" | "failed" | "refunded" | "cancelled"> = {
    approved: "succeeded",
    authorized: "succeeded",
    pending: "pending",
    in_process: "pending",
    in_mediation: "pending",
    rejected: "failed",
    refunded: "refunded",
    charged_back: "refunded",
    cancelled: "cancelled",
  };

  return statusMap[mpStatus] || "failed";
}

/**
 * Creates a card payment using Mercado Pago.
 *
 * SECURITY: This function accepts a card token (NOT raw card data) for PCI compliance.
 * The token should be generated on the client side using Mercado Pago CardForm.
 *
 * @param planId - The plan ID (essencial, premium, familia)
 * @param cardToken - Card token generated by MP CardForm on client
 * @param customerEmail - Customer email for receipt
 * @param paymentMethodId - Payment method ID (e.g., "visa", "master")
 * @param installments - Number of installments (default: 1)
 * @returns Payment details including ID and status
 */
export async function createCardPayment(
  planId: string,
  cardToken: string,
  customerEmail: string,
  paymentMethodId: string,
  installments: number = 1
) {
  const plan = PAYMENT_PRODUCTS[planId];
  if (!plan) {
    throw new Error(`Plan ${planId} not found`);
  }

  try {
    const paymentData = {
      transaction_amount: plan.price / 100, // Convert cents to reais
      token: cardToken,
      description: plan.description,
      installments: installments,
      payment_method_id: paymentMethodId,
      payer: {
        email: customerEmail,
      },
      metadata: {
        plan_id: planId,
        plan_name: plan.name,
      },
    };

    const result = await payment.create({ body: paymentData });

    // Store payment transaction in database
    try {
      await createPaymentTransaction({
        mpPaymentId: String(result.id),
        mpPaymentMethodId: paymentMethodId,
        amount: plan.price,
        currency: "brl",
        status: mapPaymentStatus(result.status ?? "pending"),
        paymentMethod: "card",
        customerEmail,
        planId,
        metadata: {
          mp_status: result.status,
          mp_status_detail: result.status_detail,
        },
      });
    } catch (error) {
      console.error("[Payment] Failed to store payment transaction:", error);
      // Don't fail the payment if database storage fails
    }

    return {
      id: String(result.id),
      status: result.status,
      statusDetail: result.status_detail,
      amount: result.transaction_amount,
      currency: result.currency_id,
      paymentMethodId: result.payment_method_id,
    };
  } catch (error: any) {
    console.error("[Payment] Error creating card payment:", error);
    throw new Error(`Card payment failed: ${error.message || "Unknown error"}`);
  }
}

/**
 * Creates a PIX payment using Mercado Pago.
 *
 * @param planId - The plan ID (essencial, premium, familia)
 * @param customerEmail - Customer email
 * @param firstName - Customer first name
 * @param lastName - Customer last name
 * @param cpf - Customer CPF (11 digits)
 * @returns Payment details including QR code and expiration
 */
export async function createPixPayment(
  planId: string,
  customerEmail: string,
  firstName: string,
  lastName: string,
  cpf: string
) {
  const plan = PAYMENT_PRODUCTS[planId];
  if (!plan) {
    throw new Error(`Plan ${planId} not found`);
  }

  try {
    const paymentData = {
      transaction_amount: plan.price / 100, // Convert cents to reais
      description: plan.description,
      payment_method_id: "pix",
      payer: {
        email: customerEmail,
        first_name: firstName,
        last_name: lastName,
        identification: {
          type: "CPF",
          number: cpf,
        },
      },
      metadata: {
        plan_id: planId,
        plan_name: plan.name,
      },
    };

    const result = await payment.create({ body: paymentData });

    // Extract PIX-specific data
    const pixQrCode = result.point_of_interaction?.transaction_data?.qr_code || "";
    const pixQrCodeBase64 = result.point_of_interaction?.transaction_data?.qr_code_base64 || "";
    const pixExpirationDate = result.date_of_expiration ? new Date(result.date_of_expiration) : null;

    // Store payment transaction in database
    try {
      await createPaymentTransaction({
        mpPaymentId: String(result.id),
        amount: plan.price,
        currency: "brl",
        status: mapPaymentStatus(result.status ?? "pending"),
        paymentMethod: "pix",
        customerEmail,
        planId,
        pixQrCode,
        pixQrCodeBase64,
        pixExpirationDate,
        externalReference: result.external_reference,
        notificationUrl: result.notification_url,
        metadata: {
          mp_status: result.status,
          mp_status_detail: result.status_detail,
        },
      });
    } catch (error) {
      console.error("[Payment] Failed to store payment transaction:", error);
      // Don't fail the payment if database storage fails
    }

    return {
      id: String(result.id),
      status: result.status,
      statusDetail: result.status_detail,
      amount: result.transaction_amount,
      currency: result.currency_id,
      pixQrCode,
      pixQrCodeBase64,
      pixExpirationDate: pixExpirationDate?.toISOString(),
    };
  } catch (error: any) {
    console.error("[Payment] Error creating PIX payment:", error);
    throw new Error(`PIX payment failed: ${error.message || "Unknown error"}`);
  }
}

/**
 * Gets the current status of a payment from Mercado Pago.
 *
 * @param paymentId - The Mercado Pago payment ID
 * @returns Payment status details
 */
export async function getPaymentStatus(paymentId: string) {
  try {
    const result = await payment.get({ id: paymentId });

    // Update database with current status
    try {
      const dbStatus = mapPaymentStatus(result.status ?? "pending");

      await updatePaymentTransactionStatus(
        paymentId,
        dbStatus,
        result.status_detail || undefined
      );
    } catch (error) {
      console.error("[Payment] Failed to update payment transaction status:", error);
      // Don't fail the status retrieval if database update fails
    }

    return {
      id: String(result.id),
      status: result.status,
      statusDetail: result.status_detail,
      amount: result.transaction_amount,
      currency: result.currency_id,
    };
  } catch (error: any) {
    console.error("[Payment] Error getting payment status:", error);
    throw new Error(`Failed to get payment status: ${error.message || "Unknown error"}`);
  }
}

/**
 * Creates a payment transaction record in the database.
 * Called after creating a payment with Mercado Pago.
 */
export async function createPaymentTransaction(data: {
  mpPaymentId: string;
  mpPaymentMethodId?: string;
  amount: number;
  currency: string;
  status: "pending" | "succeeded" | "failed" | "refunded" | "cancelled";
  paymentMethod: "card" | "pix" | "boleto";
  customerEmail?: string;
  planId: string;
  subscriptionId?: number;
  pixQrCode?: string;
  pixQrCodeBase64?: string;
  pixExpirationDate?: Date | null;
  externalReference?: string;
  notificationUrl?: string;
  metadata?: Record<string, unknown>;
}): Promise<number> {
  const db = await getDb();
  if (!db) {
    console.warn("[Payment] Cannot create payment transaction: database not available");
    throw new Error("Database not available");
  }

  try {
    const record: InsertPaymentTransaction = {
      mpPaymentId: data.mpPaymentId,
      mpPaymentMethodId: data.mpPaymentMethodId,
      amount: data.amount,
      currency: data.currency,
      status: data.status,
      paymentMethod: data.paymentMethod,
      customerEmail: data.customerEmail,
      planId: data.planId,
      subscriptionId: data.subscriptionId,
      pixQrCode: data.pixQrCode,
      pixQrCodeBase64: data.pixQrCodeBase64,
      pixExpirationDate: data.pixExpirationDate,
      externalReference: data.externalReference,
      notificationUrl: data.notificationUrl,
      metadata: data.metadata ? JSON.stringify(data.metadata) : null,
    };

    const [result] = await db.insert(paymentTransactions).values(record).returning({ id: paymentTransactions.id });

    if (!result) {
      throw new Error("Failed to create payment transaction");
    }

    return result.id;
  } catch (error) {
    console.error("[Payment] Error creating payment transaction:", error);
    throw error;
  }
}

/**
 * Updates a payment transaction status in the database.
 * Called when payment status changes (e.g., from pending to succeeded).
 */
export async function updatePaymentTransactionStatus(
  mpPaymentId: string,
  status: "pending" | "succeeded" | "failed" | "refunded" | "cancelled",
  failureReason?: string
): Promise<void> {
  const db = await getDb();
  if (!db) {
    console.warn("[Payment] Cannot update payment transaction: database not available");
    return;
  }

  try {
    await db
      .update(paymentTransactions)
      .set({
        status,
        failureReason: failureReason || null,
        updatedAt: new Date(),
      })
      .where(eq(paymentTransactions.mpPaymentId, mpPaymentId));
  } catch (error) {
    console.error("[Payment] Error updating payment transaction:", error);
    throw error;
  }
}

/**
 * Retrieves a payment transaction by Mercado Pago payment ID.
 */
export async function getPaymentTransaction(mpPaymentId: string) {
  const db = await getDb();
  if (!db) {
    console.warn("[Payment] Cannot get payment transaction: database not available");
    return null;
  }

  try {
    const [transaction] = await db
      .select()
      .from(paymentTransactions)
      .where(eq(paymentTransactions.mpPaymentId, mpPaymentId))
      .limit(1);

    return transaction || null;
  } catch (error) {
    console.error("[Payment] Error getting payment transaction:", error);
    return null;
  }
}

/**
 * Creates a subscription record in the database.
 * Called after successful payment to track user subscription.
 */
export async function createSubscription(data: {
  userId: number;
  userType: "funeral_home" | "family_user" | "oauth_user";
  planId: string;
  mpCustomerId?: string;
  mpSubscriptionId?: string;
  status: "active" | "cancelled" | "expired" | "past_due" | "trialing";
  currentPeriodStart: Date;
  currentPeriodEnd: Date;
  memorialId?: number;
}): Promise<number> {
  const db = await getDb();
  if (!db) {
    console.warn("[Payment] Cannot create subscription: database not available");
    throw new Error("Database not available");
  }

  try {
    const record: InsertSubscription = {
      userId: data.userId,
      userType: data.userType,
      planId: data.planId,
      mpCustomerId: data.mpCustomerId,
      mpSubscriptionId: data.mpSubscriptionId,
      status: data.status,
      currentPeriodStart: data.currentPeriodStart,
      currentPeriodEnd: data.currentPeriodEnd,
      cancelAtPeriodEnd: false,
      memorialId: data.memorialId,
    };

    const [result] = await db.insert(subscriptions).values(record).returning({ id: subscriptions.id });

    if (!result) {
      throw new Error("Failed to create subscription");
    }

    return result.id;
  } catch (error) {
    console.error("[Payment] Error creating subscription:", error);
    throw error;
  }
}

/**
 * Gets all active subscriptions for a user.
 */
export async function getUserSubscriptions(userId: number, userType: "funeral_home" | "family_user" | "oauth_user") {
  const db = await getDb();
  if (!db) {
    console.warn("[Payment] Cannot get subscriptions: database not available");
    return [];
  }

  try {
    return await db
      .select()
      .from(subscriptions)
      .where(and(eq(subscriptions.userId, userId), eq(subscriptions.userType, userType)));
  } catch (error) {
    console.error("[Payment] Error getting subscriptions:", error);
    return [];
  }
}

/**
 * Gets the plan details for a given plan ID.
 */
export function getPlanDetails(planId: string) {
  return PAYMENT_PRODUCTS[planId] || null;
}
